/**
 * Created by vishnu on 20/5/16.
 */
module.exports = HashSet;

function HashSet(inputArray) {
    this.uniqueArray = inputArray? initArray(arguments):[];
}
HashSet.prototype.add = function(item) {


    if (isObject(item) && !isArray(item)) {
        if (!checkContains(this.uniqueArray, item)) {
            this.uniqueArray.push(item);
        }
    }

    if (isArray(item)) {
        var merge=[];
        for(var i=0;i<arguments.length;i++){
            for(var j=0;j<arguments[i].length;j++){
                merge.push(arguments[i][j]);
            }
        }

        var filterItem1 =  [];
        filterItem1 =  filterArray(merge);
        for (var k = 0; k < filterItem1.length; k++) {
            if (!checkContains(this.uniqueArray, filterItem1[k])) {
                this.uniqueArray.push(filterItem1[k]);
            }
        }
    }

    if (isDate(item)) {
        if (!checkContains(this.uniqueArray, item)) {
            this.uniqueArray.push(item);
        }
    }

    if (isNumber(item)) {
        for (var i = 0; i < arguments.length; i++) {
            if (!checkContains(this.uniqueArray, arguments[i])) {
                this.uniqueArray.push(arguments[i]);
            }
        }
    }

    if (isString(item)) {
        for (var i = 0; i < arguments.length; i++) {
            if (!checkContains(this.uniqueArray, arguments[i])) {
                this.uniqueArray.push(arguments[i]);
            }
        }
    }

    return this.uniqueArray;
};

HashSet.prototype.contains = function(item) {
    if (!isArray(item)) {
        return checkContains(this.uniqueArray, item);
    } else {
        var falge = true;
        var uniqItem = filterArray(item);
        for (var i = 0; i < uniqItem.length; i++) {
            if (!checkContains(this.uniqueArray, uniqItem[i])) {
                falge = false;
                break;
            }
        }
        return falge;
    }
};

HashSet.prototype.remove = function(item) {
    if (checkContains(this.uniqueArray, item)) {
        for (var i = 0; i < this.uniqueArray.length; i++) {
            if (equals(this.uniqueArray[i], item)) {
                this.uniqueArray.splice(i, 1);
            }
        }
        return this.uniqueArray;
    } else {
        throw Error('Sorry object not found')
    }

};

// clear Method
HashSet.prototype.clear = function() {
    this.uniqueArray = [];
    return this.uniqueArray;
};


// size Method
HashSet.prototype.size = function() {
    return this.uniqueArray.length;
};

//unique Method 
HashSet.prototype.unique = function(inputArray) {
    return filterArray(inputArray);
};


// keyBase Method
HashSet.prototype.keyBase = function(inputArray,key) {
    var obj = inputArray[0];
    if (obj.hasOwnProperty(key)) {
        var result = inputArray;
        for (var i = 0; i < inputArray.length; i++) {
            for (var j = 0; j < inputArray.length; j++) {
                if (i != j) {
                    if (equals(inputArray[i][key], inputArray[j][key])) {
                        result.splice(result.indexOf(inputArray[j]), 1);
                    }
                }
            }
        }
        return result;
    } else {

        throw Error('Sorry please pass correct a key')
    }
};


HashSet.prototype.get = function() {
    return this.uniqueArray;
};


//uniqueConcat Method
function uniqueConcat(item){
    var merge=[];
    for(var i=0;i<arguments.length;i++){
        for(var j=0;j<arguments[i].length;j++){
            merge.push(arguments[i][j]);
        }
    }
    return filterArray(merge);
}

//initArray
function initArray(item){
    var merge=[];
    for(var i=0;i<item.length;i++){
        for(var j=0;j<item[i].length;j++){
            merge.push(item[i][j]);
        }
    }
    return filterArray(merge);
}

//checkContains Method
function checkContains(inputArray  , val ) {
    var falge = false;
    for (var i = 0; i < inputArray.length; i++) {
        if(equals(inputArray[i] , val)){
            falge=true;
        }
    }
    return  falge;
}



//filterArray Method
function filterArray(inputArray) {
    var result = inputArray;
    for (var i = 0; i < inputArray.length; i++) {
        for (var j = 0; j < inputArray.length; j++) {
            if (i != j) {
                if (equals(inputArray[i], inputArray[j])) {
                    result.splice(result.indexOf(inputArray[j]), 1);
                }
            }
        }
    }
    return result;
}


// Helper functions

function isUndefined(value){
    return typeof value === 'undefined';
}

function isDefined(value){
    return typeof value !== 'undefined';
}

function isString(value){
    return typeof value === 'string';
}

function isObject(value){
    return value != null && typeof value === 'object';
}

function isNumber(value){
    return typeof value === 'number';
}

function isBoolean(value) {
    return typeof value === 'boolean';
}


var isArray = (function() {
    if (!isFunction(Array.isArray)) {
        return function(value) {
            return toString.call(value) === '[object Array]';
        };
    }
    return Array.isArray;
})();

function isFunction(value){return typeof value === 'function';}

function isRegExp(value) {
    return toString.call(value) === '[object RegExp]';
}

function isDate(value) {
    return toString.call(value) === '[object Date]';
}

function isScope(obj) {
    return obj && obj.$evalAsync && obj.$watch;
}

function isWindow(obj) {
    return obj && obj.document && obj.location && obj.alert && obj.setInterval;
}



function equals(o1, o2) {
    if (o1 === o2) return true;
    if (o1 === null || o2 === null) return false;
    if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
    var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
    if (t1 == t2) {
        if (t1 == 'object') {
            if (isArray(o1)) {
                if (!isArray(o2)) return false;
                if ((length = o1.length) == o2.length) {
                    for (key = 0; key < length; key++) {
                        if (!equals(o1[key], o2[key])) return false;
                    }
                    return true;
                }
            } else if (isDate(o1)) {
                return isDate(o2) && o1.getTime() == o2.getTime();
            } else if (isRegExp(o1) && isRegExp(o2)) {
                return o1.toString() == o2.toString();
            } else {
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return false;
                keySet = {};
                for (key in o1) {
                    if (key.charAt(0) === '$' || isFunction(o1[key])) continue;
                    if (!equals(o1[key], o2[key])) return false;
                    keySet[key] = true;
                }
                for (key in o2) {
                    if (!keySet.hasOwnProperty(key) &&
                        key.charAt(0) !== '$' &&
                        o2[key] !== undefined && !isFunction(o2[key])) return false;
                }
                return true;
            }
        }
    }
    return false;
}

